import sqlite3
from copy import copy
from database_errors import InvalidInitializer, InvalidSize
from gevent.event import Event
from gevent.queue import Queue
import gevent
from shemutils import Logger

'# Define static variables for module'
INTEGER = "INTEGER"
TEXT = "TEXT"
NULL = "NULL"


class Controller(object):
    """
    Controller object made to control execution operations
    """
    def __init__(self, objects):
        if len(objects) < 2:
            del self
        self.handle = objects[0]
        self.cursor = objects[1]
        self.logger = None
        self.queue = Queue()

    def _log(self, s):
        if self.logger:
            self.logger.debug(s)
        return 0

    def _error(self, s):
        if self.logger:
            self.logger.error(s)
        return 0

    def execute(self, sql):
        """
        Function to execute a sql query generated by other methods from this module.
        :param sql: string containing sql query
        :return: void
        """
        if type(sql) is not str:
            return -1
        try:
            self._log("Executing SQL: {0}".format(sql))
            self.cursor.execute(sql)  # execute query passed to function
            d = self.cursor.fetchall()  # actual data returned by the query
            n = len(d)  # number of elements returned by the query
            if n > 0:
                self._log("Adding query result with {0} elements to queue ...".format(n))
                self.queue.put(d)
            else:
                self._log("Speficied query does not returned any result.")
        except sqlite3.OperationalError as e:
            self._error("Error executing query: {0}".format(e))
            raise sqlite3.OperationalError
        self._log("Executed SQL successfully\n")
        return

    def get(self):
        """
        Function to get the top element of result's queue.
        :return: Queue top element, or -1 error
        """
        try:
            if self.queue.empty() is False:
                return self.queue.get()
            else:
                return []
        except gevent.hub.LoopExit:
            self._error("Error retrieving data from queue")
            return -1


class Database(object):
    def __init__(self, db_name, verbose=False):
        """
        Database object to control data storage
        Procedures:
            1. Database opening
            2. Controller creation
        :param db_name: string
        """

        '# --------------------------------------- #'
        '# Natural variables '
        self.db_filename = self._parse_db_name(db_name)
        self.open = Event()  # this Flag is used to get database status concerning its ability to operate.
        self.logger = Logger("DATABASE", logfile="%s.log" % db_name)
        '# --------------------------------------- #'

        '# Try to open database fd'
        handle, cursor = self._open()
        '# Give the handles and cursor to Controller Object'
        self.controller = Controller((handle, cursor))
        if verbose is not False:
            self.controller.logger = self.logger

    def _open(self):
        try:
            handle = sqlite3.connect(self.db_filename)
            cursor = handle.cursor()
            self.open.set()
            return handle, cursor
        except Exception as e:
            self.logger.error("Error opening database: {0}".format(e))
            return None

    @staticmethod
    def _parse_db_name(db_filename, extension=".db"):
        k = len(db_filename)
        if db_filename[k-3:] != extension:
            db_filename += extension
        return db_filename

    def save(self):
        return self.controller.handle.commit()

    def close(self):
        return self.controller.handle.close() if self.controller.handle is not None else None


class Table(object):
    """
    To create a table use the following syntax:
    t1 = Table("TableName", {"Name":TEXT, "Age":INTEGER})
    """
    def __init__(self, name, columns):
        self.name = str(name)
        self.columns = columns if self._validate(columns) is 0 else None
        self.num_col = len(self.columns) if self.columns is not None else None

    @staticmethod
    def _validate(columns):
        if type(columns) != dict:
            raise InvalidInitializer
        return 0

    def _colstr(self):
        output = ""
        if not self.columns:
            return -1
        for column in self.columns.keys():
            p = self.columns[column]
            output += "{0} {1}, ".format(p[0], p[1])
        return output[:-2] + ")"

    def create(self):
        """
        :return: string containing SQL to construct the table
        """
        return "CREATE TABLE IF NOT EXISTS {0} (id INTEGER PRIMARY KEY AUTOINCREMENT, {1}".format(self.name,
                                                                                                  self._colstr())

    def remove_row(self, c, k):
        """
        :param c: string containing column name
        :param k: string to search through table
        :return: string containing SQL query to do the desired operation
        """
        return "DELETE FROM {0} WHERE {1} = '{2}'".format(self.name, c, k)

    def remove_rows(self, c, k):
        """
        :param c: string containing column name
        :param k: string to search through table
        :return: string containing SQL query to do the desired operation
        """
        return "DELETE FROM {0} WHERE {1} LIKE '%{2}%'".format(self.name, c, k)

    def update_row(self, c2, k, c1, v):
        """
        :param c1: string containing column to be updated
        :param v: string containing new value for the row
        :param c2: string containing column name for the query condition
        :param k: string containing keyword value for the query condition
        :return: string containing SQL query to do the desired operation
        """
        return "UPDATE {0} SET {1} = '{2}' WHERE {3} LIKE '%{4}%'".format(self.name, c1, k, c2, v)

    def search(self, t, k, c=None):
        """
        Function to generate a sql query to retrieve information from a database.
        :param t: String containing column name for the query condition
        :param k: String containing keyword value for the query condition
        :param c: None or string containing a list with column names desired for information retrieval
        :return: string containing SQL query to do the desired operation
        """
        if c is None:  # all columns
            c = "*"
        else:  # if specified any column list
            if type(c) is not list:
                raise TypeError("Variable 'c' must be 'list' type.")
            k = copy(c)
            c = str()
            for p in k:
                c += "{0},".format(p)
            c = c[:-1]
        return "SELECT {0} FROM {1} WHERE {2} LIKE '%{3}%'".format(c, self.name, t, k)

    def insert_data(self, data):
        """
        :param data: list containing data in the same number of elements that this table has -1 (for id column)
        :return: string containing SQL query to do the desired operation
        """
        if type(data) != list:
            raise TypeError
        return "INSERT INTO {0} VALUES (NULL, {1})".format(self.name, self._format_data(data))

    def _format_data(self, data):
        output = ""
        if type(data) != list:
            raise TypeError
        if len(data) != self.num_col:
            raise InvalidSize
        for d in data:
            output += "'{0}', ".format(d)
        return output[:-2]
